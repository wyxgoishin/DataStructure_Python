"""
题目描述：
    数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。
    每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。
    您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
举例：
    输入: cost = [10, 15, 20]
    输出: 15
    解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。

    输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
    输出: 6
    解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
注意：
    cost 的长度将会在 [2, 1000]。
    每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。
题解：
    动态规划法：
        假设数组cost的长度为 n ，则 n 个阶梯分别对应下标 0 到 n-1，楼层顶部对应下标 n，问题等价于计算达到下标 n 的最小花费。可以通过动态规划求解。
        创建长度为 n+1 的数组 dp，其中 dp[i] 表示达到下标 i 的最小花费。
        由于可以选择下标 0 或 1 作为初始阶梯，因此有 dp[0] = dp[1] = 0。
        当 2 ≤ i ≤ n 时，可以从下标 i-1 使用 cost[i−1] 的花费达到下标 i，或者从下标 i−2 使用 cost[i−2] 的花费达到下标 i。为了使总花费最小，
        dp[i] 应取上述两项的最小值，因此状态转移方程如下：
                dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])
        依次计算 dp 中的每一项的值，最终得到的 dp[n] 即为达到楼层顶部的最小花费。

"""

def minCostClimbingStairs(cost):
    prev = curr = 0
    for i in range(2, len(cost) + 1):
        nxt = min(curr + cost[i - 1], prev + cost[i - 2])
        prev, curr = curr, nxt
    return curr

cost = [0, 0, 1, 1]
costs = minCostClimbingStairs(cost)
print("min cost: %d" % costs)
